#============ LC Plotting Script for SAAO Pipeline Photometry Output ==========#
# 1) Place this file in the same directory containing the reduction directory 
# generated by the SAAO pipeline created by Alex Chaushev.
#
# 2) Identify target and comparison object numbers from annotated map generated
# by SAAO pipeline.
#
# 3) Change variables below accordingly and run script
#==============================================================================#

import numpy as np
import matplotlib.pyplot as plt
from astropy.stats import sigma_clip
from os.path import join
from astropy.table import Table
import warnings

warnings.simplefilter('ignore')

def bin_to_size(data, num_points_bin):
    '''Convenience function to bin everything to a fixed num of points per
    bin. Data is clipped to the nearest bin (i.e. data % num_points_bin are
    discarded from the end of the time series).'''
    num_bins = int(len(data) / num_points_bin)
    return rebin(data[0:num_bins*num_points_bin], num_bins)

def rebin(a, *args):
    '''From the scipy cookbook on rebinning arrays
    rebin ndarray data into a smaller ndarray of the same rank whose dimensions
    are factors of the original dimensions. eg. An array with 6 columns and 4 
    rows can be reduced to have 6,3,2 or 1 columns and 4,2 or 1 rows.
    example usages:
    a=rand(6,4); b=rebin(a,3,2)
    a=rand(6); b=rebin(a,2)'''
    shape = a.shape
    lenShape = len(shape)
    factor = np.asarray(shape)/np.asarray(args)
    evList = ['a.reshape('] + \
             ['args[%d],factor[%d],'%(i,i) for i in range(lenShape)] + \
             [')'] + ['.sum(%d)'%(i+1) for i in range(lenShape)] + \
             ['/factor[%d]'%i for i in range(lenShape)]
    #print ''.join(evList)
    return eval(''.join(evList))

def air_corr(flux_r, jd, jd_oot_l, jd_oot_u):
    '''Function to remove a 2-D polynomial fit using the out of transit
    region.
    
    #Define out of transit region in JD.
    #Both initialised to 5 until LC is produced, normalising by median value
    #over all LC. Once ingress/egress are identified, values can be refined.
    #Set LOWER limit TO 0 if no period before INGRESS
    #Set UPPER limit HIGH (~5) if no period after EGRESS   
    '''

    #Divide out residual airmass using out of transit region
    if airmass_correct == 'Yes':
        oot = ((jd < jd_oot_l) | (jd > jd_oot_u)) & (np.isfinite(flux_r)) & (np.isfinite(jd))
        poly1 = np.poly1d(np.polyfit(jd[oot], flux_r[oot], 2))
        p1 = poly1(jd)
        flux_r /= p1

    return flux_r


def make_lc_plots(flux, jd, name, o_num, c_num, binning = 150,
        norm_flux_lower = 0.9, norm_flux_upper = 1.05): 

    #Check sizes are the same
    assert(flux.shape[0] == jd.shape[0])

    #Remove offset from jd
    off = np.floor(np.min(jd))
    jd -= off

    #Get target flux
    flux_o = flux[:,o_num]

    #Get mean of comparisons
    flux_c_m = []
    for i in c_num:
        flux_c_m.append(flux[:,i])
    flux_c_m = np.transpose(np.asarray(flux_c_m))
    flux_c_m = np.nanmean(flux_c_m, axis=1)

    #Insert mean of comparisons at end of flux array
    flux = np.append(flux, flux_c_m[:,None], axis=1)

    #insert placeholder for last column in flux array in c_num
    c_num.append(-1)

    #Iterate over comparison stars
    for i in c_num:
        if i == -1:
            print ("comparison star mean")
        else:
            print ("comparison star %d" %i)

        #Get comparison flux
        flux_c = flux[:,i]

        #Get ratio of target to comparison
        flux_r = flux_o/flux_c

        #Normalise flux
        flux_r /= np.nanmedian(flux_r)

        #Clip outliers
        flux_r[(flux_r > norm_flux_upper) | (flux_r < norm_flux_lower)] = np.nan

        #Set up plot
        plt.cla()
        plt.figure(i, figsize=(8,6), dpi=100)
        
        #Clean out nans from flux/jd
        flux_clean = flux_r[np.isfinite(flux_r)]
        jd_clean = jd[np.isfinite(flux_r)]
                  
               
        #bin block
        flux_bin = bin_to_size(flux_clean, b)
        jd_bin = bin_to_size(jd_clean, b)
                
        #Plot binned block
        plt.scatter(jd_bin, flux_bin, zorder=2, c='r')

        #Change name of file for mean
        if i == -1: i="mean"
        
        #Convert collation of blocks back to arrays and flatten
        jd_clean = np.hstack(jd_clean)
        flux_clean = np.hstack(flux_clean)

        #Plot unbinned collation of blocks
        plt.scatter(jd_clean, flux_clean, alpha=0.5, zorder=1, c='b')
        plt.title(name + ' std: %7.5f' % np.std(flux_bin))
        plt.xlabel('JD - %d' %off)
        plt.ylabel('Relative flux')
        plt.autoscale(enable=True, axis='y')
        
        #Save plots as png
        png_name = join(dir_,name + '_obj_%d_comparison_%s.png' %(o_num,str(i))) 
        plt.savefig(png_name)
        plt.close()
        #plt.show()
        
        #Save data as FITS
        jd_clean += off #Add offset back on to JD
        t_out = Table([jd_clean, flux_clean], names=('JD', 'Relative flux'))
        fits_name = join(dir_,name + '_obj_%d_comparison_%s.fits' %(o_num,str(i))) 
        t_out.write(fits_name, overwrite=True)

def differential_photometry(flux, obj_index, comp_index):
    '''Function to perform differential photometry. Expected output from the
    SAFPhot pipeline is a flux array of shape = (num_apertures, num_objects,
    num_exposures) and a obj_index = int and a comp_index = [int, int, ...,
    int] array. The obj_index variable is the index of the target object in
    the flux array while the comp_index variable is the index of the comparison
    stars.''' 
    
    #create variable to store the comparison stars
    comp_flux = np.zeros((flux.shape[0], 1, flux.shape[2]))

    #add the comparison stars together 
    for index in comp_index:
        comp_flux += flux[:, index, :] 

    #normalise the fluxes 
    flux /= 

if __name__ == "__main__":

    #Directory and file names
    dir_ = 'reduction'
    flux_file = 'NG34149_V_-_Green.dat'
    jd_file = 'NG34149_V_-_Green_jd.dat'
    name = 'NG0518-3633.34149'

    #Load the data
    flux = np.loadtxt(flux_file)
    jd = np.loadtxt(jd_file) 

    #Define target and comparison object numbers (indicies) from object number plot
    o_num = 0              # As integer
    c_num = [1, 2]      # As list

    #Perform differential photometry

    #Pick the best signal to noise

    #Call the function to make the plots
    make_lc_plots(flux_single_aperture, jd, name, o_num, c_num)

