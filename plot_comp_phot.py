#============ LC Plotting Script for SAAO Pipeline Photometry Output ==========#
# 1) Place this file in the same directory containing the reduction directory 
# generated by the SAAO pipeline created by Alex Chaushev.
#
# 2) Identify target and comparison object numbers from annotated map generated
# by SAAO pipeline.
#
# 3) Change variables below accordingly and run script
#==============================================================================#

import numpy as np
import matplotlib.pyplot as plt
import warnings; warnings.simplefilter('ignore') 

from astropy.stats import sigma_clip
from os.path import join
from astropy.table import Table

warnings.simplefilter('ignore')

def bin_to_size(data, num_points_bin):
    '''Convenience function to bin everything to a fixed num of points per
    bin. Data is clipped to the nearest bin (i.e. data % num_points_bin are
    discarded from the end of the time series).'''
    num_bins = int(len(data) / num_points_bin)
    return rebin(data[0:num_bins*num_points_bin], num_bins)

def rebin(a, *args):
    '''From the scipy cookbook on rebinning arrays
    rebin ndarray data into a smaller ndarray of the same rank whose dimensions
    are factors of the original dimensions. eg. An array with 6 columns and 4 
    rows can be reduced to have 6,3,2 or 1 columns and 4,2 or 1 rows.
    example usages:
    a=rand(6,4); b=rebin(a,3,2)
    a=rand(6); b=rebin(a,2)'''
    shape = a.shape
    lenShape = len(shape)
    factor = np.asarray(shape)/np.asarray(args)
    evList = ['a.reshape('] + \
             ['args[%d],factor[%d],'%(i,i) for i in range(lenShape)] + \
             [')'] + ['.sum(%d)'%(i+1) for i in range(lenShape)] + \
             ['/factor[%d]'%i for i in range(lenShape)]
    #print ''.join(evList)
    return eval(''.join(evList))

def air_corr(flux_r, jd, jd_oot_l, jd_oot_u):
    '''Function to remove a 2-D polynomial fit using the out of transit
    region.
    
    #Define out of transit region in JD.
    #Both initialised to 5 until LC is produced, normalising by median value
    #over all LC. Once ingress/egress are identified, values can be refined.
    #Set LOWER limit TO 0 if no period before INGRESS
    #Set UPPER limit HIGH (~5) if no period after EGRESS   
    '''

    #Divide out residual airmass using out of transit region
    if airmass_correct == 'Yes':
        oot = ((jd < jd_oot_l) | (jd > jd_oot_u)) & (np.isfinite(flux_r)) & (np.isfinite(jd))
        poly1 = np.poly1d(np.polyfit(jd[oot], flux_r[oot], 2))
        p1 = poly1(jd)
        flux_r /= p1

    return flux_r


def make_lc_plots(flux, jd, name, comp_name="mean", binning = 150,
        norm_flux_lower = 0.9, norm_flux_upper = 1.05, plot_lower = 1.00,
        plot_upper = 1.00): 
    '''Main fuction to perform the plotting of the lightcurves. Takes in
    a flux and jd array as well as some parameters for the binning and 
    clipping to be performed on the lightcurve. A comparison star name
    is passed in as well. '''

    #Check sizes are the same
    assert(flux.shape == jd.shape)

    #Remove offset from jd
    off = np.floor(np.min(jd))
    jd -= off    

    #Clip outliers
    flux[(flux > norm_flux_upper) | (flux < norm_flux_lower)] = np.nan

    #Set up plot
    plt.cla()
    plt.figure(figsize=(8,6), dpi=100)
    
    #Clean out nans from flux/jd
    flux_clean = flux[np.isfinite(flux)]
    jd_clean = jd[np.isfinite(flux)]            
           
    #bin block
    flux_bin = bin_to_size(flux_clean, binning)
    jd_bin = bin_to_size(jd_clean, binning)
            
    #Plot binned block
    plt.scatter(jd_bin, flux_bin, zorder=2, c='r')
   
    #Convert collation of blocks back to arrays and flatten
    jd_clean = np.hstack(jd_clean)
    flux_clean = np.hstack(flux_clean)

    #Plot unbinned collation of blocks
    plt.scatter(jd_clean, flux_clean, alpha=0.5, zorder=1, c='b')
    plt.title(name + ' std: %7.5f' % np.std(flux_bin))
    plt.xlabel('JD - %d' %off)
    plt.ylabel('Relative flux')

    if (plot_upper == 1.00) and (plot_lower == 1.00):
        plt.autoscale(enable=True, axis='y')
    else:
        plt.ylim((plot_lower, plot_upper))
    
    #Save plots as png
    png_name = join(dir_,name + '_comparison_%s.png' % comp_name) 
    plt.savefig(png_name, bbox_inches="tight")
    plt.close()
    #plt.show()


def save_data_fits(jd, flux, file_name, comp_name):
    '''Function to save the data as a fits file usings the astropy.io.fits
    library a.k.a PyFits.'''

    #Save data as FITS
    t_out = Table([jd, flux], names=('JD', 'Differential flux'))
    fits_name = join(file_name + '_comparison_%s.fits' % comp_name) 
    t_out.write(fits_name, overwrite=True)


def differential_photometry(flux, obj_index, comp_index):
    '''Function to perform differential photometry. Expected output from the
    SAFPhot pipeline is a flux array of shape = (num_apertures, num_objects,
    num_exposures) and a obj_index = int and a comp_index = [int, int, ...,
    int] array. The obj_index variable is the index of the target object in
    the flux array while the comp_index variable is the index of the comparison
    stars.''' 
    
    #create variable to store the comparison stars
    comp_flux = np.zeros((flux.shape[0], flux.shape[2]))

    #add the comparison stars together 
    for index in comp_index:
        comp_flux = comp_flux + flux[:, index, :] 

    #normalise the fluxes 
    obj_flux = flux[:, obj_index, :] / np.mean(flux[:, obj_index, :], axis=1).reshape((flux.shape[0], 1))  
    comp_flux /= np.mean(comp_flux, axis=1).reshape((comp_flux.shape[0], 1))

    return obj_flux / comp_flux, obj_flux, comp_flux 

if __name__ == "__main__":

    #Directory and file names
    dir_ = '/rfs/XROA/apc34/SAAO/run3/reduction/'
    flux_file = 'NG34149_V_-_Green.dat'
    jd_file = 'NG34149_V_-_Green_jd.dat'
    name = 'NG0518-3633.34149'

    #Load the data
    flux = np.loadtxt(join(dir_, flux_file))
    jd = np.loadtxt(join(dir_, jd_file))

    #Reshape the data to have the correct dimensions (3D array save in 2D format).
    num_apertures = 100
    flux = flux.reshape((num_apertures, flux.shape[0]/num_apertures, flux.shape[1])) 

    #Define target and comparison object numbers (indicies) from object number plot
    o_num = 0              # As integer
    c_num = [1, 2]      # As list

    #Perform differential photometry using mean comparison star
    diff_flux, obj_flux, comp_flux = differential_photometry(flux, o_num, c_num)

    #Pick the best signal to noise
    signal = np.mean(diff_flux, axis=1) #should be approximately 1 
    noise = np.std(diff_flux, axis=1) #should be a small numbers 
    sn_max = np.where(signal/noise == max(signal/noise))
   
    #Print the signal to noise
    print "Signal to noise is approximately: %f" % (signal/noise)[sn_max]
    
    #Call the function to make the plots
    make_lc_plots(diff_flux[sn_max][0, :], jd, name, comp_name="mean", binning = 150,
        norm_flux_lower = 0.9, norm_flux_upper = 1.05)

    print "Mean plot finished."

    make_lc_plots(diff_flux[sn_max][0, :], jd, name, comp_name="mean_bin",
            plot_lower = 0.997, plot_upper = 1.003)

    print "Mean zoomed plot finished."

    #Work through the comparison stars at optimal s/n and plots those

    for cindex in c_num:

        diff_flux, obj_flux, comp_flux = differential_photometry(flux, o_num,
                [cindex])
    
        signal = np.mean(diff_flux, axis=1) #should be approximately 1 
        noise = np.std(diff_flux, axis=1) #should be a small numbers 
        sn_max = np.where(signal/noise == max(signal/noise))
   
        make_lc_plots(diff_flux[sn_max][0, :], jd, name, comp_name=str(cindex))

        make_lc_plots(diff_flux[sn_max][0, :], jd, name,
                comp_name=str(cindex)+"_bin", plot_lower=0.997,
                plot_upper=1.003)

        print "Comparison plot for comp star %i is finished." % cindex


